/**
 * Composite is a component that may contain navigable items represented by
 * CompositeItem. It's inspired by the WAI-ARIA Composite Role and implements
 * all the keyboard navigation mechanisms to ensure that there's only one
 * tab stop for the whole Composite element. This means that it can behave as
 * a roving tabindex or aria-activedescendant container.
 *
 * @see https://ariakit.org/components/composite
 */

/**
 * WordPress dependencies
 */
import { forwardRef } from '@wordpress/element';
import deprecated from '@wordpress/deprecated';

/**
 * Internal dependencies
 */
import * as Current from '../current';
import { useInstanceId } from '@wordpress/compose';

type Orientation = 'horizontal' | 'vertical';

export interface InitialStateProps {
	baseId?: string;
	unstable_virtual?: boolean;
	rtl?: boolean;
	orientation?: Orientation;
	currentId?: string;
	loop?: boolean | Orientation;
	wrap?: boolean | Orientation;
	shift?: boolean;
}

type Component = {
	( ...any: any ): React.ReactElement | null;
	displayName?: string;
};

type CompositeStore = ReturnType< typeof Current.useCompositeStore >;
type CompositeStoreState = { store: CompositeStore };
export type CompositeState = CompositeStoreState &
	Required< Pick< InitialStateProps, 'baseId' > >;

// Legacy composite components can either provide state through a
// single `state` prop, or via individual props, usually through
// spreading the state generated by `useCompositeState`.
// That is, `<Composite* { ...state }>`.
export type CompositeStateProps =
	| { state: CompositeState }
	| ( CompositeState & { state?: never } );
type ComponentProps< C extends Component > = React.ComponentPropsWithRef< C >;
export type CompositeProps< C extends Component > = ComponentProps< C > &
	CompositeStateProps;
type CompositeComponent< C extends Component > = (
	props: CompositeProps< C >
) => React.ReactElement;
type CompositeComponentProps = CompositeState &
	(
		| ComponentProps< typeof Current.CompositeGroup >
		| ComponentProps< typeof Current.CompositeItem >
		| ComponentProps< typeof Current.CompositeRow >
	);

function showDeprecationMessage( previous?: string, next?: string ) {
	if ( previous ) {
		deprecated( `wp.components.__unstable${ previous }`, {
			alternative: `wp.components.${ next || previous }`,
		} );
	}
}

function mapLegacyStatePropsToComponentProps(
	legacyProps: CompositeStateProps
): CompositeComponentProps {
	// If a `state` prop is provided, we unpack that; otherwise,
	// the necessary props are provided directly in `legacyProps`.
	if ( legacyProps.state ) {
		const { state, ...rest } = legacyProps;
		const { store, ...props } =
			mapLegacyStatePropsToComponentProps( state );
		return { ...rest, ...props, store };
	}

	return legacyProps;
}

function proxyComposite< C extends Component >(
	ProxiedComponent: C | React.ForwardRefExoticComponent< C >,
	propMap: Record< string, string > = {}
): CompositeComponent< C > {
	const displayName = ProxiedComponent.displayName;
	const Component = ( legacyProps: CompositeStateProps ) => {
		showDeprecationMessage( displayName );

		const { store, ...rest } =
			mapLegacyStatePropsToComponentProps( legacyProps );
		const props = rest as ComponentProps< C >;
		props.id = useInstanceId( store, props.baseId, props.id );

		Object.entries( propMap ).forEach( ( [ from, to ] ) => {
			if ( props.hasOwnProperty( from ) ) {
				Object.assign( props, { [ to ]: props[ from ] } );
				delete props[ from ];
			}
		} );

		delete props.baseId;

		return <ProxiedComponent { ...props } store={ store } />;
	};
	Component.displayName = displayName;
	return Component;
}

// The old `CompositeGroup` used to behave more like the current
// `CompositeRow`, but this has been split into two different
// components. We handle that difference by checking on the
// provided role, and returning the appropriate component.
const unproxiedCompositeGroup = forwardRef<
	any,
	React.ComponentPropsWithoutRef<
		typeof Current.CompositeGroup | typeof Current.CompositeRow
	>
>( ( { role, ...props }, ref ) => {
	const Component =
		role === 'row' ? Current.CompositeRow : Current.CompositeGroup;
	return <Component ref={ ref } role={ role } { ...props } />;
} );
unproxiedCompositeGroup.displayName = 'CompositeGroup';

export const Composite = proxyComposite( Current.Composite, { baseId: 'id' } );
export const CompositeGroup = proxyComposite( unproxiedCompositeGroup );
export const CompositeItem = proxyComposite( Current.CompositeItem, {
	focusable: 'accessibleWhenDisabled',
} );

export function useCompositeState(
	initialState: InitialStateProps = {}
): CompositeState {
	showDeprecationMessage( 'UseCompositeState', 'useCompositeStore' );

	const {
		baseId,
		currentId: defaultActiveId,
		orientation,
		rtl = false,
		loop: focusLoop = false,
		wrap: focusWrap = false,
		shift: focusShift = false,
		// eslint-disable-next-line camelcase
		unstable_virtual: virtualFocus,
	} = initialState;

	return {
		baseId: useInstanceId( Composite, 'composite', baseId ),
		store: Current.useCompositeStore( {
			defaultActiveId,
			rtl,
			orientation,
			focusLoop,
			focusShift,
			focusWrap,
			virtualFocus,
		} ),
	};
}
